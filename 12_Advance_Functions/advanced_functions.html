<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Advanced Functions</title>
  </head>


  <body>
      <button onclick="" class="js-button">Click</button>
    <script>
      /*
      const buttonElement = document.querySelector('.js-button');

      buttonElement.addEventListener('click', () => {
        console.log('click');
      });

      const eventList = () => {console.log('click')};

      buttonElement.addEventListener('click',eventList);

      buttonElement.removeEventListener('click',eventList);
      */

      /*

      // When we use this syntax it give us an advantage of "Hoisting" meaning we can call the function before we create it in the code which is a good thing. 


      function greeting() {
        console.log('hello');
      }
      greeting();

      // Functions are value

      const num = 2;

      // When we save the fucntion in a varibale "Hoisting" doesn't work because we can't call variable before creating it.
      const function1 = function () {
        console.log('hello2');
      }
      console.log(function1);
      console.log(typeof function1);

      function1();

      // Functions are value, so that we can save them in objects. When function saved inside object, we call it as method.
      const object1 = {
        num: 2,
        fun: function greeting() {
          console.log('hello3');
        }
          
      };
      object1.fun();

      // As we can call function using "fun", there is no need to add name to the function.
      const object2 = {
        num: 3,
        fun: function() {
          console.log("hello4")
        }
      };
      object2.fun();

      // passing a value into a function. Now functions are also values, we can pass functions in function.
      function display(param) {
        console.log(param);
      };
      display(2);


      // So here you can see that we are calling param meaning param(); which basically means we passed function in "param" and becuase we passed function we can call it using param().
      // The function we are passing in is called "Callback" function or a "callback".
      function run(param) {
        param();
      };
      run(function() {
        console.log('hello5')
      })

      // setTimeout() is a function and we use it to run function in future. 
      // It takes 2 parameter. 1st is the function you want run and 2nd is time in milliseconds. 1000 milliseconds = 1 sec.
      setTimeout(function() {
        console.log('timeout')
        console.log('timeout2')
      },3000);

      console.log('next line') // You can see in output that 1st "next line" is printing and then "timeout". What is happening? So when I set 3 sec time in setTimeout, it starts a counting of 3 sec but immediately moves to next line which means it doesn't wait for "setTimeout" to excecute and this is called Asynchronus nature of JS which basically means, computer won't wait for a line to finish before going to the next line.
      // Synchronous code means computer will wait for one line to finish before going to the next line.
      // Code is "setTomeout" function is synchronous as you can see in the output that "timeout" will print first and then "timeout2".
      // Advantage of Asynchronous code is it doesn't block our code for 3 seconds.


      setInterval(function() {
        console.log('Interval');
      }, 3000);

      console.log('next line 2');

      */

      /*

      [
        'make dinner',
        'wash dishes',
        'watch youtube'
      ].forEach(function(value, index) {

        if (value === 'wash dishes') {
          return;
        };

        console.log(index);
        console.log(value);
      });

      // Arrow functions

      const regularFunction = function (param, param2) {
        console.log('hello')
        return 5;
      };

      const arrowFunction = (param, param2) => {
        console.log('hello');
        return 5;
      };
      arrowFunction();

      // When "arrow function" has only one parameter, we can write "param" instead of (param).

      const oneParam = param => {
        console.log(param + 1);
      };

      oneParam(2);

      // This is one line arrow function. It will return (2+3) =5
      const oneLine = () => 2 + 3;
      console.log(oneLine());




      [
        'make dinner',
        'wash dishes',
        'watch youtube'
      ].forEach((value, index) => {
        if (value === 'wash dishes') {
          return;
        }
        console.log(value);
      })

      const object6 = {
        method: () => {

        },
        method() {

        }
      }
      */ 

      // FILTER function
      // It creates a new array[]. If function returns "TRUE" then value will go in new array and if it returns "FALSE" then value will not go in new array.

      console.log([1,-3,5].filter((value, index) => {
        /*
        if (value >= 0) {
          return true;
        } else {
          return false;
        } */ 
        return value >= 0;
      }));


      // MAP function

      console.log([1,1,3].map((value, index) => {
        return value * 2;
      }));

      console.log([1,1,3].map(value =>value * 2));

      // "CLOSURE" meaning if a function has access to a value, it will always have access to that value.

      

;    </script>

  </body>


</html>
