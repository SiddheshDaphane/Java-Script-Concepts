<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Objects</title>
    
  </head>


  <body>

    <script>

      /* 

      const product = {
        name: 'socks',
        price: 1090
      };

      // "name" and "price" are called as properties in the object. "socks" and "1090" are values. "name: 'scoks" is called property-value pair.

      console.log(product); // This will display all the values and properties in the object. This will show us all properties and it's values. 

      console.log(product.name); // This is used when we need a value of a perticular property. Output is 'socks'

      console.log(product.price); // Same as above line of code. 

      product.name = 'cotton socks'; // This changes the value of a property. First it was 'socks' and now it is 'cotton socks'

      console.log(product);

      console.log(product.sales); // This will give output as "undefined"

      product.newProperty = true; // This is use to add new property with it's value

      console.log(product); // New property will be in the output.

      delete product.newProperty; // This will delete "newProperty"

      console.log(product); // "newProperty" will not come in the output.

      console.log(typeof product); // "product" is an object.

      /* Objects: 
      1) let us group multiple values together
      2) let us use multiple values together
      
      

      
      const product2 = {
        name: 'shirt',
        ['delivery-time']: '1 day',
        rating: {
          stars: 4.5,
          count: 87
        },
        fun: function function1() {
          console.log('function inside object');
        }
      };
      console.log(product2);

      console.log(product2['name']); // does same thing as 'product2.name'.

      // '[]' lets us use properties that don't work with dot notation.

      console.log(product2['delivery-time']);


      //console.log(product2.delivery-time); // we can't use .delivery-time because JavaScript thinks that '-' is a minus sign and that's why in the out it is giving an error instead of undefined. 

      
      console.log(product2.rating.count)

      product2.fun() // When we save function inside an object we call it as 'method'.

      console.log(typeof console.log) // So 'log' is a function saved inside an object called 'console'


      // JSON(JavaScript object notation) Built-in Object. JSON doesn't support functions.



      // Converting JS object (product2) to JSON

      console.log(JSON.stringify(product2)); // output is in string

      console.log(typeof JSON.stringify(product2));


      // converting JSON to JS object

      const jsonString = JSON.stringify(product2);
      console.log(JSON.parse(jsonString));


      // localStorage built in object. It is used to save values more permanently.

      // Variables are temporary. If we refresh/ close the page, all the variables are deleted.

      */ 


      console.log('hello'.length);

      console.log('hello'.toUpperCase());
      // How can strings have properties and methods? Answer is, JavaScript has a special method called "Auto-boxing." JavaScript automatically wraps this string in a special object first, and this object has the property length and the method to uppercase. So this is done automatically. Auto-boxing works with numbers and bools but it doesn't work with 'null' and 'undefined'. It will just give us an error.

      // Objects are references. 

      const object1 = {
        messgae: 'hello'
      }; // when we create this object, the actual value i.e. " message: 'hello' " is created somewhere in the computer's memory, and "object1" variable actually just gets a reference that points to that location in the computers memory. 

      const object2 = object1; // So this code doesn't make copy of above code. It just makes a copy of the reference that points to the object. This is called "Copy by Reference."

      object1.messgae = 'Good job!'

      console.log(object1); // Even though we created "object1" with "const" we can change the values of property because, "object1" just contains reference and not original value. So "const" just prevent us for referrence but it does not prevent us to change the values in the reference.

      console.log(object2);

      // We can't compare objects directly. 

      const object3 = {
        messgae: 'Good job!'
      };

      console.log(object3 === object1); // objects are references. Both references are different and that's why they are not same.

      console.log(object2 === object1); // because they have same reference. 

      const object4 = {
        message: 'Good job!',
        price: 799
      };
      // const message = object4.messgae;

      const { message, price } = object4; // This line of code basically means, value of  "message" and "price" attribute from "object4" will be saved in a variable called "message" and "price".
      console.log(message);
      console.log(price);

      const object5 = {
        // message: message
        message, // this is called "Shorthand property"
        
        //method: function function1() {
         // console.log('method')
       // }

        method() { // same as above function. It is called "Shorthand Method"
          console.log('method')
        }
       }

      console.log(object5);
      object5.method();
    </script>

  </body>


</html>

